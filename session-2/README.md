# Session 2 - Code Dojo

## Kata / Problem

### Even Fibbonacci numbers

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

Source: <https://projecteuler.net/problem=2>

## Learning steps

### TDD workflow

Start with the brute force implementation in a test, for a library. Let's write this test based on the defitinion of the fibbonacci numbers, so we can trust the result.

```rust
#[test]
fn should_be_44_for_cutoff_50() {
    // Given
    let cutoff = 50;

    // When

    // Yes we can have local functions in functions
    fn fib(n: u64) -> u64 {
        match n {
            0 => 1,
            1 => 2,
            _ => fib(n - 1) + fib(n - 2),
        }
    }
    let sum_even_fib = (0..)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum();

    assert_eq!(44u64, sum_even_fib);
}
```

Now extract that function into the library.

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    fn fib(n: u64) -> u64 {
        match n {
            0 => 1,
            1 => 2,
            _ => fib(n - 1) + fib(n - 2),
        }
    }
    (0..cutoff)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}
```

Now you can use this to determine the result for `4_000_000`, if interessted in solving the project euler problem.

```rust
#[test]
fn should_be_44_for_cutoff_50() {
    // Given
    let cutoff = 50;

    // When
    let sum_even_fib = sum_even_fib(cutoff);

    // Then
    assert_eq!(44, sum_even_fib);
}

#[test]
fn should_cutoff_for_4_000_000() {
    // Given
    let cutoff = 4_000_000;

    // When
    let sum_even_fib = sum_even_fib(cutoff);

    // Then
    assert_eq!(4613732, sum_even_fib);
}
```

### Property based testing

Of course our implementation is currently brute force. Surly we can do better. However, often if we have an easy to understand solution it is a good idea to use it for property based testing, to verify the solution which might be more difficult to understand.

Copy the simple brute force implementation to the testframework again, and use it to generate an expectation for the first `1000` values.

```rust
#[test]
fn should_be_identical_to_slow_and_simple_solution() {
    for n in 0..=1000 {
        assert_eq!(
            sum_even_fib_slow_and_simple(n),
            sum_even_fib(n)
        )
    }
}

fn sum_even_fib_slow_and_simple(cutoff: u64) -> u64 {
    fn fib(n: u64) -> u64 {
        match n {
            0 => 1,
            1 => 2,
            _ => fib(n - 1) + fib(n - 2),
        }
    }
    (0..)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}
```

### Iterative development of the fast solution

Now lets go for the fast solution. Using state instead of recursion:

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    fn fib(n: u64) -> u64 {
        match n {
            0 => 1,
            1 => 2,
            _ => fib(n - 1) + fib(n - 2),
        }
    }
    (0..)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}
```

iteration

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    (0..)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}

fn fib(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 2,
        _ => fib(n - 1) + fib(n - 2),
    }
}
```

iteration

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    let fib_it = (0..).map(fib);
    fib_it
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}
```

iteration

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    fib_it()
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}

fn fib_it() -> impl Iterator<Item=u64> {
    (0..).map(fib)
}
```

Now we leave the top level method alone and iterate on the responsibility between these two:

```rust
fn fib_it() -> impl Iterator<Item=u64> {
    (0..).map(fib)
}

fn fib(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 2,
        _ => fib(n - 1) + fib(n - 2),
    }
}
```

iterate (introduce state without using it yet)

```rust
fn fib_it() -> impl Iterator<Item=u64> {
    (0..).scan((1,2), |(a,b), i| { Some(fib(i)) })
}
```

iteration (use new state)

```rust
fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan((1, 2), |(a, b), i| {
        let new = *a + *b;
        *a = *b;
        *b = new;
        Some(new)
    })
}
```

Oh no, tests error. We now miss the first two elements of the sequence. Let's start two elements earlier

iteration

```rust
fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan((0, 1), |(a, b), _| {
        let new = *a + *b;
        *a = *b;
        *b = new;
        Some(new)
    })
}
```

iteration

```rust
struct Fib {
    a: u64,
    b: u64,
}

fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan(Fib { a: 0, b: 1 }, |fib, _| {
        let new = fib.a + fib.b;
        fib.a = fib.b;
        fib.b = new;
        Some(new)
    })
}
```

iteration

```rust
impl Fib {
    pub fn new() -> Fib {
        Fib { a: 0, b: 1 }
    }
}

fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan(Fib::new(), |fib, _| {
        let new = fib.a + fib.b;
        fib.a = fib.b;
        fib.b = new;
        Some(new)
    })
}
```

iteration

```rust
impl Fib {
    pub fn new() -> Fib {
        Fib { a: 0, b: 1 }
    }

    pub fn next(&mut self) -> u64 {
        let new = self.a + self.b;
        self.a = self.b;
        self.b = new;
        new
    }
}

fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan(Fib::new(), |fib, _| Some(fib.next()))
}
```

iteration

```rust
impl Fib {
    pub fn new() -> Fib {
        Fib { a: 0, b: 1 }
    }

    pub fn next(&mut self) -> u64 {
        (self.a, self.b) = (self.b, self.a + self.b);
        self.b
    }
}

fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan(Fib::new(), |fib, _| Some(fib.next()))
}
```

iteration

```rust
struct Fib {
    a: u64,
    b: u64,
}

impl Fib {
    pub fn new() -> Fib {
        Fib { a: 0, b: 1 }
    }
}

impl Iterator for Fib {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        (self.a, self.b) = (self.b, self.a + self.b);
        Some(self.b)
    }
}

fn fib_it() -> Fib {
    Fib::new()
}
```

Final solution

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    FibSeq::new()
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}

struct FibSeq {
    a: u64,
    b: u64,
}

impl FibSeq {
    pub fn new() -> FibSeq {
        FibSeq { a: 0, b: 1 }
    }
}

impl Iterator for FibSeq {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        (self.a, self.b) = (self.b, self.a + self.b);
        Some(self.b)
    }
}
```

Please notice how we:

* Could compile and test between each step
* Did develop the solution top down (starting with a single test case)
* The test caught my off by two error
* We introduced `Fib` as state only first; Made it hide his members second (SLA); Introduced trait impl Third.
