# Session 2 - Code Dojo

## Kata / Problem

### Even Fibbonacci numbers

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

Source: <https://projecteuler.net/problem=2>

## Learning steps

### TDD workflow

Start with the brute force implementation in a test, for a library. Hardcode the test to `10` and expect `23` as in the problem definition.

```rust
#[test]
fn should_be_44_for_cutoff_50() {
    // Given
    let cutoff = 50;

    // When

    // Yes we can have local functions in functions
    fn fib(n: u64) -> u64 {
        match n {
            0 => 1,
            1 => 2,
            _ => fib(n - 1) + fib(n - 2),
        }
    }
    let sum_even_fib = (0..)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum();

    assert_eq!(44u64, sum_even_fib);
}
```

Now extract that function into the library.

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    fn fib(n: u64) -> u64 {
        match n {
            0 => 1,
            1 => 2,
            _ => fib(n - 1) + fib(n - 2),
        }
    }
    (0..cutoff)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}
```

Now you can use this to determine the result for `4_000_000`, if interessted in solving the project euler problem.

```rust
#[test]
fn should_be_44_for_cutoff_50() {
    // Given
    let cutoff = 50;

    // When
    let sum_even_fib = sum_even_fib(cutoff);

    // Then
    assert_eq!(44, sum_even_fib);
}

#[test]
fn should_cutoff_for_4_000_000() {
    // Given
    let cutoff = 4_000_000;

    // When
    let sum_even_fib = sum_even_fib(cutoff);

    // Then
    assert_eq!(4613732, sum_even_fib);
}
```

### Property based testing

Of course our implementation is currently brute force. Surly we can do better. However, often if we have an easy to understand solution it is a good idea to use it for property based testing, to verify the solution which might be more difficult to understand.

Copy the simple brute force implementation to the testframework again, and use it to generate an expectation for the first `1000` values.

```rust
#[test]
fn should_be_identical_to_slow_and_simple_solution() {
    for n in 0..=1000 {
        assert_eq!(
            multiples_of_5_and_3_slow_and_simple(n),
            multiples_of_5_and_3(n)
        )
    }
}

fn sum_even_fib_slow_and_simple(cutoff: u64) -> u64 {
    fn fib(n: u64) -> u64 {
        match n {
            0 => 1,
            1 => 2,
            _ => fib(n - 1) + fib(n - 2),
        }
    }
    (0..)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}
```

### Iterative development of the fast solution

Now lets go for the fast solution. Using state instead of recursion:

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    fn fib(n: u64) -> u64 {
        match n {
            0 => 1,
            1 => 2,
            _ => fib(n - 1) + fib(n - 2),
        }
    }
    (0..cutoff)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}
```

iteration

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    (0..)
        .map(fib)
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}

fn fib(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 2,
        _ => fib(n - 1) + fib(n - 2),
    }
}
```

iteration

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    let fib_it = (0..).map(fib);
    fib_it
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}
```

iteration

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    fib_it()
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}

fn fib_it() -> impl Iterator<Item=u64> {
    (0..).map(fib)
}
```

Now we leave the top level method alone and iterate on the responsibility between these two:

```rust
fn fib_it() -> impl Iterator<Item=u64> {
    (0..).map(fib)
}

fn fib(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 2,
        _ => fib(n - 1) + fib(n - 2),
    }
}
```

iterate (introduce state without using it yet)

```rust
pub fn sum_even_fib(cutoff: u64) -> u64 {
    fib_it()
        .filter(|n| n % 2 == 0)
        .take_while(|&n| n <= cutoff)
        .sum()
}

fn fib_it() -> impl Iterator<Item=u64> {
    (0..).scan((1,2), |(a,b), i| { Some(fib(i)) })
}
```

iteration

```rust
fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan((1, 2), |(a, b), i| {
        let new = *a + *b;
        *a = *b;
        *b = new;
        Some(new)
    })
}

fn fib(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 2,
        _ => fib(n - 1) + fib(n - 2),
    }
}
```

iteration

```rust
fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan((1, 2), |(a, b), _| {
        let new = *a + *b;
        *a = *b;
        *b = new;
        Some(new)
    })
}
```

```rust
struct Fib {
    a: u64,
    b: u64,
}

fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan(Fib { a: 1, b: 2 }, |fib, _| {
        let new = fib.a + fib.b;
        fib.a = fib.b;
        fib.b = new;
        Some(new)
    })
}
```

```rust
impl Fib {
    pub fn new() -> Fib {
        Fib { a: 1, b: 2 }
    }
}

fn fib_it() -> impl Iterator<Item = u64> {
    (0..).scan(Fib::new(), |fib, _| {
        let new = fib.a + fib.b;
        fib.a = fib.b;
        fib.b = new;
        Some(new)
    })
}
```

Final solution

```rust
```

Please notice how we:

* Could compile and test between each step
* Did develop the solution top down (starting with a single test case)
